% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bsm.R, R/gssm.R
\name{run_mcmc.bsm}
\alias{run_mcmc.bsm}
\alias{run_mcmc.gssm}
\title{Bayesian Inference of State Space Models using MCMC with RAM}
\usage{
\method{run_mcmc}{bsm}(object, n_iter, nsim_states = 1, type = "full",
  lower_prior, upper_prior, n_burnin = floor(n_iter/2), n_thin = 1,
  gamma = 2/3, target_acceptance = 0.234, S, end_adaptive_phase = TRUE,
  log_space = FALSE, n_threads = 1, seed = sample(.Machine$integer.max,
  size = 1), thread_seeds = sample(.Machine$integer.max, size = n_threads),
  ...)

\method{run_mcmc}{gssm}(object, n_iter, Z_est, H_est, T_est, R_est,
  nsim_states = 1, type = "full", lower_prior, upper_prior,
  n_burnin = floor(n_iter/2), n_thin = 1, gamma = 2/3,
  target_acceptance = 0.234, S, end_adaptive_phase = TRUE,
  seed = sample(.Machine$integer.max, size = 1), ...)
}
\arguments{
\item{object}{Model object.}

\item{n_iter}{Number of MCMC iterations.}

\item{nsim_states}{Number of simulations of states per MCMC iteration. Only
used when \code{type = "full"}.}

\item{type}{Type of output. Default is \code{"full"}, which returns
samples from the posterior \eqn{p(\alpha, \theta}. Option
\code{"parameters"} samples only parameters \eqn{\theta} (which includes the
regression coefficients \eqn{\beta}). This can be used for faster inference of
\eqn{\theta} only, or as an preliminary run for obtaining
initial values for \code{S}. Option \code{"summary"} does not simulate
states directly computes the  posterior means and variances of states using
fast Kalman smoothing. This is slightly faster, memory  efficient and
more accurate than calculations based on simulation smoother.}

\item{lower_prior, upper_prior}{Bounds of the uniform prior for parameters
\eqn{\theta}. Optional for \code{bsm} objects.}

\item{n_burnin}{Length of the burn-in period which is disregarded from the
results. Defaults to \code{n_iter / 2}.}

\item{n_thin}{Thinning rate. Defaults to 1. Increase for large models in
order to save memory.}

\item{gamma}{Tuning parameter for the adaptation of RAM algorithm. Must be
between 0 and 1 (not checked).}

\item{target_acceptance}{Target acceptance ratio for RAM. Defaults to 0.234.}

\item{S}{Initial value for the lower triangular matrix of RAM
algorithm, so that the covariance matrix of the Gaussian proposal
distribution is \eqn{SS'}.}

\item{log_space}{Generate proposals for standard deviations in log-space. Default is \code{FALSE}.}

\item{n_threads}{Number of threads for state simulation.}

\item{seed}{Seed for the random number generator.}

\item{thread_seeds}{Seeds for threads.}

\item{...}{Ignored.}

\item{Z_est, H_est, T_est, R_est}{Arrays or matrices containing \code{NA}
values marking the unknown parameters which are to be estimated. Must be of
same dimension as the corresponding elements of the model object.}
}
\description{
For general univariate Gaussian models, all \code{NA} values in
\code{Z}, \code{H}, \code{T}, and \code{R} are estimated without any constraints
(expect the bounds given by the uniform priors).
}
\details{
Note that currently it is not possible to set some parameters equal to each
other, so for example stochastic trigonometric seasonal and cycle components
cannot be used (the corresponding errors are usually assumed i.i.d.).

Note that the proposal for all parameters is multivariate Gaussian,
with uniform priors for each parameters. For \code{\link{bsm}} models,
generating proposals for standard deviations in log-scale is also possible
with argument \code{log_space = TRUE}.
}
\examples{
init_sd <- 0.1 * sd(log10(UKgas))
model <- bsm(log10(UKgas), sd_y = init_sd, sd_level = init_sd,
  sd_slope = init_sd, sd_seasonal = init_sd)
set.seed(123)
mcmc_out <- run_mcmc(model, n_iter = 5000)
names(mcmc_out)
mcmc_out$acceptance_rate
plot(mcmc_out$theta)
summary(mcmc_out$theta)
ts.plot(log10(UKgas), rowMeans(mcmc_out$alpha[, "level", ]), col = 1:2)
pred <- predict(model, n_iter = 5000, n_ahead = 8, S = mcmc_out$S)
ts.plot(pred$y, pred$mean, pred$interval, col = c(1, 2, 2, 2),
  lty = c(1, 1, 2, 2))
}

