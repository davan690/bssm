% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bsm.R, R/generics.R, R/gssm.R, R/ng_bsm.R, R/ngssm.R
\name{run_mcmc.bstsm}
\alias{run_mcmc}
\alias{run_mcmc.bstsm}
\alias{run_mcmc.gssm}
\alias{run_mcmc.ng_bstsm}
\alias{run_mcmc.ngssm}
\title{Bayesian Inference of State Space Models using MCMC with RAM}
\usage{
\method{run_mcmc}{bstsm}(object, n_iter, type = "full", lower_prior,
  upper_prior, nsim_states = 1, n_burnin = floor(n_iter/2), n_thin = 1,
  gamma = 2/3, target_acceptance = 0.234, S,
  seed = sample(.Machine$integer.max, size = 1), log_space = FALSE, ...)

run_mcmc(object, n_iter, type, lower_prior, upper_prior, nsim_states, n_burnin,
  n_thin, gamma, target_acceptance, S, ...)

\method{run_mcmc}{gssm}(object, n_iter, type = "full", lower_prior,
  upper_prior, nsim_states = 1, n_burnin = floor(n_iter/2), n_thin = 1,
  gamma = 2/3, target_acceptance = 0.234, S, Z_est, H_est, T_est, R_est,
  seed = sample(.Machine$integer.max, size = 1), ...)

\method{run_mcmc}{ng_bstsm}(object, n_iter, lower_prior, upper_prior,
  nsim_states = 1, n_burnin = floor(n_iter/2), n_thin = 1, gamma = 2/3,
  target_acceptance = 0.234, S, method = "delayed acceptance",
  seed = sample(.Machine$integer.max, size = 1), n_store = 1,
  n_threads = 1, thread_seeds = sample(.Machine$integer.max, size =
  n_threads), log_space = FALSE, ...)

\method{run_mcmc}{ngssm}(object, n_iter, lower_prior, upper_prior,
  nsim_states = 1, n_burnin = floor(n_iter/2), n_thin = 1, gamma = 2/3,
  target_acceptance = 0.234, S, Z_est, T_est, R_est,
  seed = sample(.Machine$integer.max, size = 1), ...)
}
\arguments{
\item{object}{Object of class \code{gssm} or \code{bstsm}.}

\item{n_iter}{Number of MCMC iterations.}

\item{type}{Type of output. Default is \code{"full"}, which returns
samples from the posterior \eqn{p(\alpha, \theta}. Option
\code{"parameters"} samples only parameters \eqn{\theta} (which includes the
regression coefficients \eqn{\beta}). This can be used for faster inference of
\eqn{\theta} only, or as an preliminary run for obtaining
initial values for \code{S}. Option \code{"summary"} does not simulate
states directly computes the  posterior means and variances of states using
fast Kalman smoothing. This is slightly faster, memory  efficient and
more accurate than calculations based on simulation smoother.}

\item{lower_prior, upper_prior}{Bounds of the uniform prior for parameters
\eqn{\theta}. Optional for \code{bstsm} objects.}

\item{nsim_states}{Number of simulations of states per MCMC iteration. Only
used when \code{type = "full"}.}

\item{n_burnin}{Length of the burn-in period which is disregarded from the
results. Defaults to \code{n_iter / 10}.}

\item{n_thin}{Thinning rate. Defaults to 1. Increase for long time series in
order to save memory.}

\item{gamma}{Tuning parameter for the adaptation of RAM algorithm. Must be
between 0 and 1 (not checked).}

\item{target_acceptance}{Target acceptance ratio for RAM.}

\item{S}{Initial value for the lower triangular matrix of RAM
algorithm, so that the covariance matrix of the Gaussian proposal
distribution is \eqn{SS'}.}

\item{...}{Ignored.}

\item{Z_est, H_est, T_est, R_est}{Arrays or matrices containing \code{NA}
values marking the unknown parameters which are to be estimated. Must be of
same dimension as the corresponding elements of the model object.}
}
\description{
Adaptive Markov chain Monte Carlo simulation of state space models using
Robust Adaptive Metropolis algorithm by Vihola (2012).
Function

Note that currently it is not possible to set some parameters equal to each
other, so for example stochastic trigonometric seasonal and cycle components
cannot be used (the corresponding errors are usually assumed i.i.d.).
}
\details{
Note that the proposal for all parameters is multivariate Gaussian,
with uniform priors for each parameters.
}
\examples{
init_sd <- 0.1 * sd(log10(UKgas))
model <- bsm(log10(UKgas), sd_y = init_sd, sd_level = init_sd,
  sd_slope = init_sd, sd_seasonal = init_sd)
set.seed(123)
mcmc_out <- run_mcmc(model, n_iter = 5000)
names(mcmc_out)
mcmc_out$acceptance_rate
plot(mcmc_out$theta)
summary(mcmc_out$theta)
ts.plot(log10(UKgas), rowMeans(mcmc_out$alpha[, "level", ]), col = 1:2)
pred <- predict(model, n_iter = 5000, n_ahead = 8, S = mcmc_out$S)
ts.plot(pred$y, pred$mean, pred$interval, col = c(1, 2, 2, 2),
  lty = c(1, 1, 2, 2))
}
\references{
Vihola, Matti (2012). "Robust adaptive Metropolis algorithm with
coerced acceptance rate". Statistics and Computing, Volume 22, Issue 5,
pages 997--1008.
}

