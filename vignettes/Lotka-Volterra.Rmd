---
title: "Lotka-Volterra model with bssm"
author: "Jouni Helske"
date: "13 February 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Lotka-Volterra model

This vignette shows how to model general non-linear state space models with `bssm`. The example is taken from [Stefan Gelissen's blog post for Extended Kalman filter](http://blogs2.datall-analyse.nl/2016/02/11/rcode_extended_kalman_filter/). The general non-linear Gaussian model in `bssm` has following form:

$$
y_t = Z(t, \alpha_t, \theta, \psi, \psi_t) + H(t, \alpha_t, \theta, \psi, \psi_t)\epsilon_t,\\
\alpha_{t+1} = T(t, \alpha_t, \theta, \psi, \psi_t) + R(t, \alpha_t, \theta, \psi, \psi_t)\eta_t,\\
\alpha_1 \sim N(a_1(\theta, \psi), P_1(\theta, \psi)),
$$
with $t=1,\ldots, n$, $\epsilon_t ~ N(0,\textrm{I}_p)$, and $\eta ~ N(0,\textrm{I}_k)$. Here vector $\theta$ contains the unknown model parameters, $\psi$ contains known time-invariant parameters, and $\psi_t$ consists of $n \times r$ matrix of time-varying parameters. Functions $T(\cdot)$, $H(\cdot)$, $T(\cdot)$, $R(\cdot)$,$a_1(\cdot)$, $P_1(\cdot)$, as well as functions defining the Jacobians of $Z(\cdot)$ and $T(\cdot)$ and the prior distribution for $\theta$ must be defined by user as a external pointers to `C++` functions, which can sound intimidating at first, but is actually pretty simple, as this vignette hopefully illustrates.

But let's first simulate some data:
```{r data}
set.seed(1)

dt <- 1 / 5000 # time step for Euler integration
tt <- 7 # upper bound of time window
st <- seq(0, tt, by = dt) # lower time bounds of the integration intervals
ns <- length(st) # number of Euler integrations
x <- matrix(0, ns, 2) # specify matrix for states
x[1,] <- c(400, 200) # respective amounts of prey and predators at t=0
colnames(x) <- c("Prey", "Predators")

# parameters in the Lotka-Volterra model
alpha <- 1
beta <- 1/300
delta <- 1/200
gamma <- 1

# simulate true states
for (i in 2:ns) {
  # prey population
  x[i,1] <- x[i-1,1] + (alpha * x[i-1,1] - beta * x[i-1,1] * x[i-1,2]) * dt
  # predator population
  x[i,2] <- x[i-1,2] + (delta * x[i-1,1] * x[i-1,2] - gamma * x[i-1,2]) * dt
}

# Take measurements with a sample time of .01
dT <- .01 # sample time for measurements

nm <- tt / dT # total number of measurements
mt <- seq(dT, tt, dT) # measurement times

#standard deviations for the measurement noise
sigmaPrey <- 7 
sigmaPred <- 10

# measurements at specified measurement times
yprey <- sapply(1:nm, function(i) x[i * ((ns - 1) / nm) + 1, 1] + 
    rnorm(1, 0, sigmaPrey))
ypred <- sapply(1:nm, function(i) x[i * ((ns - 1) / nm) + 1, 2] + 
    rnorm(1, 0, sigmaPred))

#store measurement data
y <- cbind(yprey, ypred)
```

## Model in bssm

Let's make less than optimal initial guess for $theta$, and define the prior distribution for $\alpha_1$:
```{r theta}
initial_theta <- c(
  alpha = 1.2,
  beta = 1/200,
  delta = 1/40,
  gamma = 1.1,
  sdPrey = 5,
  sdPred = 5
)

# dT, a1 and the prior variance
psi <- c(dT, 350, 250, 100);
```
The functions determining the model functions are given in file `model_functions.cpp`. Here are few pieces from the file. The first one defines the 
state transition function $T(\cdot)$:

```{Rcpp, eval = FALSE}
arma::vec T_fn(const unsigned int t, const arma::vec& alpha, 
  const arma::vec& theta, const arma::vec& known_params, 
  const arma::mat& known_tv_params) {
  
  double dT = known_params(0);
  
  double prey = alpha(0);
  double pred = alpha(1);
  arma::vec alpha_new(2);
  alpha_new(0) = prey + (theta(0) * prey - theta(1) * prey * pred) * dT;
  alpha_new(1) = pred + (theta(2) * prey * pred - theta(3) * pred) * dT;
  return alpha_new;
}
```

The name of this function does not matter, but it should always return Armadillo vector (`arma::vec`), and have same signature (ie. the order and types of the function's parameters) should always be like above, even though some of the parameters were not used in the body of the function. For details of using Armadillo, see [Armadillo documentation](http://arma.sourceforge.net/docs.html). After defining the appropriate model functions, the `cpp` file should also contain a function for creating external pointers for the aforementioned functions. Why this is needed is more technical issue, but fortunately you can just copy the function from the example file without any modifications. 

After creating the file for `C++` functions, you need to compile the file using `Rcpp`:

```{r pointers}
Rcpp::sourceCpp("vignettes/model_functions.cpp")
pntrs <- create_xptrs()
```

This takes a few seconds. If you have used line `// [[Rcpp::export]]` before the model functions, you can now test that the functions work as intended:

```{r test}
T_fn(0, c(100, 200), initial_theta, psi, matrix(1))
```

Now the actual model:
```{r model}
library(bssm)
model <- nlg_ssm(y = y, a1=pntrs$a1, P1 = pntrs$P1, 
  Z = pntrs$Z_fn, H = pntrs$H_fn, T = pntrs$T_fn, R = pntrs$R_fn, 
  Z_gn = pntrs$Z_gn, T_gn = pntrs$T_gn,
  theta = initial_theta, log_prior_pdf = pntrs$log_prior_pdf,
  known_params = psi, known_tv_params = matrix(1),
  n_states = 2, n_etas = 2)
```

Let's first run Extended Kalman filter and smoother (note that currently we use fast state smoother which does not return smoothed covariances):
```{r ekf}
out_filter <- ekf(model)
out_smoother <- ekf_smoother(model)

ts.plot(cbind(y, out_filter$att, out_smoother),col=rep(1:3,each=2))
```
Doesn't look good. Let's try again with known parameter values (initial state is still off though):
```{r true_theta}
true_model <- model
true_model$theta <- c(
  alpha = 1,
  beta = 1/300,
  delta = 1/200,
  gamma = 1,
  sdPrey = 7,
  sdPredator = 10
)
out_filter2 <- ekf(true_model)
out_smoother2 <- ekf_smoother(true_model)

ts.plot(cbind(y, out_filter2$att, out_smoother2),col=rep(1:3,each=2))
```
Looks good.

## Markov chain Monte Carlo

Instead of EKF-based analysis, we can perform full Bayesian inference on the Lotka-Volterra model. The MCMC algorithm is based on pseudo-marginal particle MCMC with bootstrap filter, but other algorithms are currently being implemented as well. Also, we need to supply some redundant 
stuff to the function at the moment, working on it...

```{r mcmc}
out<-particle_filter(model,nsim=1000,seed=1)
out$log

out <- run_mcmc(model, n_iter = 2000, nsim_states = 100, max_iter=0, method = "pm",
  simulation_method = "bsf",
  initial_mode = out_smoother, delayed_acceptance = FALSE, S = diag(0.1,6))
```
## Appendix

This is the full `model_functions.cpp` file:
  
```{Rcpp, eval = FALSE}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::interfaces(r, cpp)]]

// Function for the prior mean of alpha_1
// [[Rcpp::export]]
arma::vec a1_fn(const arma::vec& theta, const arma::vec& known_params) {
 
  arma::vec a1(2);
  a1(0) = known_params(1);
  a1(1) = known_params(2);
  return a1;
}
// Function for the prior covariance matrix of alpha_1
// [[Rcpp::export]]
arma::mat P1_fn(const arma::vec& theta, const arma::vec& known_params) {
  
  arma::mat P1(2, 2, arma::fill::zeros);
  P1.diag().fill(known_params(3));
  return P1;
}

// Function for the Cholesky of observational level covariance
// [[Rcpp::export]]
arma::mat H_fn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  arma::mat H(2, 2,arma::fill::zeros);
  H(0, 0) = theta(4);
  H(1, 1) = theta(5);
  return H;
}

// Function for the Cholesky of state level covariance
// [[Rcpp::export]]
arma::mat R_fn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  arma::mat R(2, 2, arma::fill::zeros);
  return R;
}


// Z function
// [[Rcpp::export]]
arma::vec Z_fn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  return alpha;
}
// Jacobian of Z function
// [[Rcpp::export]]
arma::mat Z_gn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  arma::mat Z_gn(2, 2, arma::fill::zeros);
  Z_gn(0, 0) = 1.0;
  Z_gn(1, 1) = 1.0;
  return Z_gn;
}

// T function
// [[Rcpp::export]]
arma::vec T_fn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  
  double dT = known_params(0);
  
  double prey = alpha(0);
  double pred = alpha(1);
  arma::vec alpha_new(2);
  alpha_new(0) = prey + (theta(0) * prey - theta(1) * prey * pred) * dT;
  alpha_new(1) = pred + (theta(2) * prey * pred - theta(3) * pred) * dT;
  return alpha_new;
}

// Jacobian of T function
// [[Rcpp::export]]
arma::mat T_gn(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
  const arma::vec& known_params, const arma::mat& known_tv_params) {
  
  double dT = known_params(0);
  
  double prey = alpha(0);
  double pred = alpha(1);
  
  arma::mat Tg(2, 2);
  Tg(0, 0) = 1.0 + (theta(0) - theta(1) * pred) * dT;
  Tg(0, 1) = - theta(1) * prey * dT;
  Tg(1, 0) = theta(2) * pred * dT;
  Tg(1, 1) = 1.0 + (theta(2) * prey - theta(3)) * dT;
  
  
  return Tg;
}



// # log-prior pdf for theta
// [[Rcpp::export]]
double log_prior_pdf(const arma::vec& theta) {
  
  double log_pdf;
  if(arma::any(theta <= 0)) {
    log_pdf = -arma::datum::inf;
  } else {
    //just testing, U(0, 1000) for everything
    log_pdf = -6.0 * log(1000);
  }
  return log_pdf;
}

// Create pointers, no need to touch this if
// you don't alter the function names above
// [[Rcpp::export]]
Rcpp::List create_xptrs() {
  // typedef for a pointer of nonlinear function of model equation returning vec
  typedef arma::vec (*vec_fnPtr)(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
    const arma::vec& known_params, const arma::mat& known_tv_params);
  // typedef for a pointer of nonlinear function of model equation returning mat
  typedef arma::mat (*mat_fnPtr)(const unsigned int t, const arma::vec& alpha, const arma::vec& theta, 
    const arma::vec& known_params, const arma::mat& known_tv_params);
  // typedef for a pointer of nonlinear function of model equation returning vec
  typedef arma::vec (*vec_initfnPtr)(const arma::vec& theta, const arma::vec& known_params);
  // typedef for a pointer of nonlinear function of model equation returning mat
  typedef arma::mat (*mat_initfnPtr)(const arma::vec& theta, const arma::vec& known_params);
  // typedef for a pointer of log-prior function
  typedef double (*double_fnPtr)(const arma::vec&);
  
  return Rcpp::List::create(
    Rcpp::Named("a1_fn") = Rcpp::XPtr<vec_initfnPtr>(new vec_initfnPtr(&a1_fn)),
    Rcpp::Named("P1_fn") = Rcpp::XPtr<mat_initfnPtr>(new mat_initfnPtr(&P1_fn)),
    Rcpp::Named("Z_fn") = Rcpp::XPtr<vec_fnPtr>(new vec_fnPtr(&Z_fn)),
    Rcpp::Named("H_fn") = Rcpp::XPtr<mat_fnPtr>(new mat_fnPtr(&H_fn)),
    Rcpp::Named("T_fn") = Rcpp::XPtr<vec_fnPtr>(new vec_fnPtr(&T_fn)),
    Rcpp::Named("R_fn") = Rcpp::XPtr<mat_fnPtr>(new mat_fnPtr(&R_fn)),
    Rcpp::Named("Z_gn") = Rcpp::XPtr<mat_fnPtr>(new mat_fnPtr(&Z_gn)),
    Rcpp::Named("T_gn") = Rcpp::XPtr<mat_fnPtr>(new mat_fnPtr(&T_gn)),
    Rcpp::Named("log_prior_pdf") = 
      Rcpp::XPtr<double_fnPtr>(new double_fnPtr(&log_prior_pdf)));
}

```

